# AUTOGENERATED! DO NOT EDIT! File to edit: 01_patrones_espacio_temporales.ipynb (unless otherwise specified).

__all__ = ['construye_malla', 'ajusta_bandwidth_kde', 'kde2D', 'serie_tiempo_kde_categoria', 'serie_razones_de_eventos',
           'serie_mapas_intensidad', 'p_value_maps']

# Cell
from sklearn.neighbors import KernelDensity
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import KFold
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from .etl import *

# Cell
def construye_malla(datos, size):
    """ Regresa una malla (np.meshgrid) ajustada al extent de los datos,
        con el tamaño de celda especificado.

        Args:
            datos (GeoDataFrame): carpetas o víctimas
            size (float): tamaño de las celdas (en las unidades de la proyección)

    """
    xmin, ymin, xmax, ymax = datos.geometry.total_bounds
    xgrid = np.arange(xmin, xmax, size)
    ygrid = np.arange(ymin, ymax, size)
    X, Y = np.meshgrid(xgrid, ygrid)
    return (X, Y)

# Cell
def ajusta_bandwidth_kde(datos, bandwidth_space, size=1000,
                         malla=None, n_jobs=-1, metric="euclidean"):
    """ Regresa el valor de bandwidth con mejor log likelihood.

        Parametros:

            datos (GeoDataFrame):  víctimas o carpetas
            bandwith_space (np.linspace):  con el espacio de búsqueda
            size (float): Tamaño de la celda (en las unidades de la proyección).
                          Si se especifica malla se ignora
            malla (np.meshgrid): la malla en la que se va a ajustar el KDE, si es None se calcula
            n_jobs (int): número de procesos a usar (default = -1)
            metric (str): métrica a usar para calcular las distancias (default euclidean)
    """
    if malla is None:
        xx, yy = construye_malla(datos, size)
    else:
        xx = malla[0]
        yy = malla[1]
    xy_sample = np.vstack([yy.ravel(), xx.ravel()]).T
    x = datos.geometry.x.to_numpy()
    y = datos.geometry.y.to_numpy()
    xy_train  = np.vstack([y, x]).T
    grid = GridSearchCV(KernelDensity(metric=metric), bandwidth_space, n_jobs=n_jobs)
    grid.fit(xy_train)
    return grid.best_estimator_.bandwidth

# Cell

def kde2D(datos, bandwidth, size=1000, malla=None):
    """ Regresa una matriz con la densidad de kernel para los datos.

        Parametros:

            datos (GeoDataFrame):  víctimas o carpetas
            bandwith: ancho del kernel gaussiano
            size (float): Tamaño de la celda (en las unidades de la proyección).
                          Si se especifica malla se ignora
            metric (str): métrica a usar para calcular las distancias (default euclidean)
            malla (np.meshgrid): la malla en la que se va a ajustar el KDE, si es None se calcula
    """
    x = datos.geometry.x.to_numpy()
    y = datos.geometry.y.to_numpy()
    if malla is None:
        X, Y = construye_malla(datos, size)
    else:
        X = malla[0]
        Y = malla[1]
    XY = np.vstack([Y.ravel(), X.ravel()]).T
    xy_train = np.vstack([y, x]).T
    kde = KernelDensity(bandwidth=bandwidth)
    kde.fit(xy_train)
    Z = np.exp(kde.score_samples(XY))
    return X, Y, np.reshape(Z, X.shape)

# Cell
def serie_tiempo_kde_categoria(carpetas, fechas, categorias, offset, size,
                               grid_search={'bandwidth': np.linspace(10, 10000, 100)},
                               bw=None):
    """ Ajusta kdes egregando los datos sobre cada categoria e intervalo de fecha.

       Args:
           carpetas: Las carpetas de investigación (preprocesadas)
           fechas: lista de fechas con los extremos de los intervalos
           categorias: Lista de categorías para calcular el KDE
           offset: intervalo para agregar antes de la primera fecha, p.ej: "30 days" si los intervalos son mensuales
           size (float): Tamaño de la celda (en las unidades de la proyección)
           grid_search: {'bandwidth': np.linspace(0.001, 0.1, 100)} valores para ajustar el bandwidth (se usa sólo si bandwidth es nulo)
           bandwidth: Si no se especifica grid_search, se tiene que dar un valor de bandwidth
           **kwargs: argumentos extra que se pasan a `kde2D`

       returns:
       (xx, yy) [zz]: la tupla (xx, yy) es el grid común de los kdes, la lista contiene los valores de z para cada intervalo
    """
    kdes = []
    fecha_inicio = fechas[0] - pd.to_timedelta(offset)
    for i, fecha in enumerate(fechas):
        # TODO: paralelizar este loop
        if i == 0:
            datos_intervalo = carpetas.loc[(carpetas['fecha_hechos'].between(fecha_inicio, fecha, inclusive='left')) &
                                           (carpetas['categoria'].isin(categorias))]
        else:
            datos_intervalo = carpetas.loc[(carpetas['fecha_hechos'].between(fechas[i-1], fecha, inclusive='left')) &
                                           (carpetas['categoria'].isin(categorias))]
        if bw is None:
            bw = ajusta_bandwidth_kde(datos_intervalo, size, grid_search)
        xx, yy, zz = kde2D(datos_intervalo, bw, size)
        kdes.append(zz)
    return xx, yy, kdes

# Cell
def serie_razones_de_eventos(carpetas, fechas, categoria, offset, size, bw):
    """Regresa el mapa de razón entre una categoría con respecto a las demás."""
    xx, yy, kdes_categoria = serie_tiempo_kde_categoria(carpetas, fechas, [categoria],
                                                        offset, size, bw=bw)
    categorias_todas = list(carpetas[carpetas.categoria.notnull()]['categoria'].unique())
    categorias_todas.remove(categoria)
    xx, yy, kdes_base = serie_tiempo_kde_categoria(carpetas, fechas,
                                                   categorias_todas, offset, size, bw=bw)
    # TODO: vectorizar esta operación np.divide(a, b, out=np.zeros_like(a), where=b!=0)
    serie_razones = [np.divide(np.round(e, 5),
                               np.round(b, 5),
                               out=np.zeros_like(e),
                               where=np.round(b, 5)!=0)
                     for e, b in zip(kdes_categoria, kdes_base)]
    return serie_razones
    # return kdes_base

# Cell
def serie_mapas_intensidad(carpetas, fechas, categoria, offset, **kwargs):
    """Regresa los mapas de razon y las intensidades de la categoría para las `fechas` seleccionadas."""
    razones = serie_razones_de_eventos(carpetas, fechas, categoria, offset, **kwargs)
    avg = np.round(np.mean(razones, axis=0), 5)
    std = np.round(np.std(razones, axis=0), 5)
    intensidad = [np.divide(r - avg, std, out=np.zeros_like(r), where=std!=0) for r in razones]
    return razones, intensidad

# Cell
def p_value_maps(razones):
    """Regresa los mapas de significancia estadística para las razones."""
    p_values = []
    for r in razones:
        comp = [b >= r for b in razones]
        comp = np.sum(comp, axis=0)
        p = comp / (len(razones) + 1)
        p_values.append(p)
    return p_values