# AUTOGENERATED! DO NOT EDIT! File to edit: 03_modelos.ipynb (unless otherwise specified).

__all__ = ['DATA_PATH', 'DOWNLOADS_PATH', 'descarga_datos_covariables', 'get_diccionario_censo', 'get_variables_censo',
           'imputa_faltantes_manzana', 'agrega_en_unidades', 'censo_a_tasas', 'get_uso_de_suelo', 'agrega_uso_suelo',
           'IndicePCA']

# Cell
import os
import glob
from pathlib import Path
import numpy as np
import pandas as pd
import geopandas as gpd
import seaborn as sns
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
import requests

# Cell
DATA_PATH = "datos/"
DOWNLOADS_PATH = "datos/descargas/"

# Cell
def descarga_datos_covariables():
    """Descarga los archivos necesarios qe son demasiado grandes para el repositorio.

        - geometrías de manzanas
    """
    covariables_url = "https://www.dropbox.com/s/s49lb476wpwu2p1/covariables.gpkg?dl=1"
    r = requests.get(covariables_url, allow_redirects=True)
    open(DOWNLOADS_PATH + 'covariables.gpkg', 'wb').write(r.content)

# Cell
def get_diccionario_censo():
    """Regresa un DataFrame con el diccionario de variables del censo."""
    dicionario = pd.read_csv("datos/diccionario_datos_ageb_urbana_09_cpv2020.csv", skiprows=3)
    diccionario = (dicionario
                   .drop(range(0,8))
                   .drop(columns='Núm.')
                   .reset_index(drop=True)
                   .rename({'Mnemónico':'Nombre del Campo'}, axis=1))
    return diccionario

# Cell
def get_variables_censo():
    """Regresa un DataFrame con las variables del censo a nivel manzana."""
    df = pd.read_csv("datos/censo_manzanas.zip", dtype={'CVEGEO':str, 'colonia_cve': 'Int64'})
    return df

# Cell
def imputa_faltantes_manzana(censo, cols, metodo='ceros'):
    """ Regresa un df con los datos faltantes imputados a nivel manzana.

        params:

        cols: list: lista con las columnas en donde se deben imputar faltantes.
        metodo: método a usar para la imputación.
        NOTA: Por lo pronto sólo implementa dos métodos muy simples: llena con ceros
        o aleatorio entre 0 y 3. En el futuro podríamos implementar mejores formas
    """
    if metodo == 'ceros':
        censo = censo.fillna(0)
    elif metodo == 'random':
        rand = pd.DataFrame(np.random.randint(0, 4, size=(censo.shape[0], len(cols))),
                            columns=cols,
                            index=censo.index)
        censo.update(rand)
    else:
        raise ValueError("imputacion debe ser ceros o random")
    return censo

# Cell
def agrega_en_unidades(censo, diccionario,
                       agregacion        = 'colonias',
                       imputacion        = 'ceros',
                       umbral_faltantes  = 0.5):
    """ Agrega las variables del censo en las unidades espaciales especificadas.

        params:
        agregacion: str: colonias/cuadrantes o nombre del campo
        imputacion: str: ceros/random. método para rellenar los datos faltantes.
                             ceros llena con ceros, random con un aleatorio entre 0 y 3
                             (faltantes por secreto)
        umbral_faltantes float: Porcentaje de datos faltantes en una manzana para
                                considerarla en el análisis

        NOTA: Las columnas PROM_HNV, GRAPROES(F/M) se pierden porque
        no hay forma de calcularlas.
    """
    vars_pob = [v for v in diccionario['Nombre del Campo'].unique()
                if (v.startswith('P') and v != 'PROM_HNV') ]
    vars_viv = [v for v in diccionario['Nombre del Campo'].unique() if v.startswith('V')]
    vars_viv.append('OCUPVIVPAR')
    if agregacion == 'colonias':
        columna_agrega = 'colonia_cve'
    elif agregacion == 'cuadrantes':
        columna_agrega = 'cuadrante_id'
    else:
        columna_agrega = agregacion
    assert columna_agrega in censo.columns
    censo.dropna(thresh=umbral_faltantes*(len(vars_pob) + len(vars_viv)), inplace=True)
    censo = imputa_faltantes_manzana(censo, vars_pob + vars_viv, metodo=imputacion)
    censo = censo[[columna_agrega] + vars_pob + vars_viv].groupby(columna_agrega).sum()
    # Calculamos las columnas que requieren trato espacial
    censo['PROM_OCUP'] = censo['OCUPVIVPAR'].div(censo['VIVPAR_HAB'])
    censo['PROM_OCUP_C'] = censo['OCUPVIVPAR'].div(censo['VPH_1CUART'] + 2*censo['VPH_2CUART'] + 3*censo['VPH_3YMASC'])
    return censo

# Cell
def censo_a_tasas(censo, diccionario, umbral_faltantes=0.5):
    """Convierte las variables del censo a tasas en la agregación seleccionada.

    Para las variables de población divide por población total.
    Para Hogares divide por TOTHOG.
    Para viviendas divide por el total de viviendas particulares
     habitadas (VIVPAR_HAB)

    params:
    umbral_faltantes float: Porcentaje de datos faltantes en una unidad para
    considerarla en el análisis
    """
    pob_col = 'POBTOT'
    hog_col = 'TOTHOG'
    viv_col = 'VIVPAR_HAB'
    vars_pob = [v for v in diccionario['Nombre del Campo'].unique() if v.startswith('P')]
    eliminar = ['POBTOT', 'PROM_HNV']
    vars_pob = [v for v in vars_pob if (v not in eliminar)]
    vars_viv = [v for v in diccionario['Nombre del Campo'].unique()
                if (v.startswith('V') and v != 'VIVPAR_HAB')]
    censo[vars_pob] = censo[vars_pob].div(censo[pob_col], axis=0)
    censo[vars_viv] = censo[vars_viv].div(censo[viv_col], axis=0)
    censo.dropna(thresh=umbral_faltantes*(len(vars_pob) + len(vars_viv)), inplace=True)
    return censo

# Cell
def get_uso_de_suelo():
    """Regresa un DataFrame con las variables de uso de suelo a nivel manzana."""
    df = pd.read_csv("datos/usos_suelo.csv", dtype={'CVEGEO':str,
                                                    'colonia_cve': 'Int64',
                                                    'cuadrante_id':str})
    return df

# Cell
def agrega_uso_suelo(usos, unidades='colonias'):
    """ Regresa un DataFrame con los usos agregados en las unidades espaciales.

        Además calcula la intensidad y la entropía para cada unidad.

        params:
        usos: DataFrame: lo que sale de `get_uso_de_suelo()`
        unidades: str: colonias/cuadrantes

        NOTA: eventualmente debe recibir unidades arbitrarias.
    """
    if unidades == 'colonias':
        columna_agrega = 'colonia_cve'
    elif unidades == 'cuadrantes':
        columna_agrega = 'cuadrante_id'
    else:
        raise ValueError("unidades debe ser 'colonias' o 'cuadrantes'")
    usos = usos.groupby(columna_agrega).sum()
    usos['Intensidad'] = usos.sum(axis=1)
    usos['Entropía'] = (np.log(usos[['Industria', 'Comercio', 'Servicios']]
                               .div(usos['Intensidad'], axis=0))
                        .sum(axis=1) / np.log(3))
    return usos

# Cell
class IndicePCA(object):
    """ Clase contenedora para los índices basados en PCA.

        Args:
            covariables: DataFrame: del mismo tipo que `agrega_en_unidades`. El índice
            del DataFrame debe ser el id de la unidad de agregación
            vars_indice: list: la lista de las columnas con las qeu calculamos el índice
    """
    def __init__(self, covariables, vars_indice):
        self.datos = covariables
        self.vars_indice = vars_indice
        self.varianza_explicada = None
        self.indice = None

    def calcula_indice(self):
        """Calcula el índice y lo guarda en self.indice"""
        pca = PCA(n_components=1, svd_solver='full', random_state=1)
        indicadores = self.datos.replace([np.inf, -np.inf], np.nan)
        indicadores = indicadores[self.vars_indice].dropna()
        X = StandardScaler().fit_transform(indicadores.values)
        pca.fit(X)
        self.varianza_explicada = pca.explained_variance_ratio_
        indice = pca.fit_transform(X)[:,:1]
        id_var = indicadores.index.name
        df = indicadores.reset_index()[[id_var]]
        df['Índice'] = abs(indice)
        self.indice = df